# ADR-001 — Orchestration synchrone par service 

- **Statut** : Accepté  
- **Date** : 2025‑07‑26  

## Contexte

Le laboratoire 6 demande une **Saga** pour la création de commande en plusieurs étapes :
1) Verrouillage du panier (`LOCK_CART`)
2) Réservation de stock (`RESERVE_STOCK`)
3) Création de vente (`CREATE_SALE`)
4) Fin réussie ou rollback en cas d’échec

Contraintes et objectifs :
- **Tests manuels simples** (curl/bash) et reproductibles.
- **Débogage rapide** (logs, tables persistées).
- **Idempotence** et **compensations**.

## Décision

Mettre en place un **service orchestrateur** qui exécute **synchronement** la séquence via des **appels HTTP** :
- Orchestrateur = point d’entrée (`POST /api/commande/`) qui enchaîne `carts → stocks → produits`.
- Persistance de l’état dans une table **`Saga`** + journal **`SagaEvent`** (`COMMANDE_CREEE`, `PANIER_VERROUILLE`, `STOCK_RESERVE`, `VENTE_CREEE`, `TERMINEE/FAILED`).
- **Compensation** en cas d’échec : `DELETE /api/stock/reservations/{id}/`, puis `POST /api/caisse/{cart_id}/unlock/`.

## Conséquences

- + **Simplicité** de mise en œuvre et de tests (curl/docker compose).
- - **Traçabilité claire** (état persistant + événements).
- - **Couplage temporel** : dépendance à la disponibilité des services pendant l’appel.

## Statut de l’implémentation

- Endpoints utilisés :
  - `carts`: `POST /api/caisse/{cart_id}/lock/`, `POST /api/caisse/{cart_id}/unlock/`
  - `stocks`: `POST /api/stock/reservations/`, `DELETE /api/stock/reservations/{id}/`
  - `produits`: `POST /api/produits/ventes/`
- Modèles : `Saga`, `SagaEvent` (orchestrateur).
- Nginx route les chemins `/api/...` vers les services internes.
- Tests bash validés : **happy‑path**, **idempotence**, **rollback**.